# 进程PCB组织、管理与调度模拟系统

## 实验概述

本实验实现了一个进程PCB（进程控制块）管理系统，所有核心算法均经过精心设计和实现：

- ✅ **伙伴系统算法**：完整实现分配、分裂、回收、合并
- ✅ **PCB总链管理**：使用HashMap高效维护所有进程
- ✅ **优先级调度**：就绪队列按优先级排序，实现优先级调度
- ✅ **完整的进程原语**：创建、撤销、时间片到、挂起、激活
- ✅ **CPU调度器**：模拟真实的CPU调度过程
- ✅ **系统快照**：记录系统在不同时刻的状态

## 功能特性

### 基本要求 ✓✓✓

1. **PCB总链队列**
   - 使用HashMap维护所有进程，key为PID
   - 支持O(1)时间复杂度的查找和更新
   - 状态变化时不改变总链结构，只更新状态

2. **菜单式管理**
   - 提供友好的交互式菜单界面
   - 支持所有进程原语操作
   - 实时显示系统状态

3. **进程原语**
   - **创建进程**：通过伙伴系统分配PCB，按优先级加入就绪队列
   - **撤销进程**：从所有队列移除，回收PCB到伙伴系统
   - **时间片到**：运行进程转为就绪，重置时间片，按优先级重新入队
   - **挂起进程**：从就绪/运行队列移除，加入等待队列
   - **激活进程**：从等待队列移除，按优先级加入就绪队列

4. **队列管理**
   - 就绪队列：按优先级排序（优先级高的在前）
   - 等待队列：FIFO
   - 运行队列：单进程运行

### 扩展一 ✓✓✓：伙伴系统策略

**核心算法**：
1. **分配算法**：
   - 从空闲列表中查找最小的可用块
   - 如果块太大，递归分裂成两个伙伴块
   - 返回分配的块索引

2. **回收算法**：
   - 释放指定索引的块
   - 计算伙伴块索引（使用XOR运算）
   - 如果伙伴块空闲，合并成更大的块
   - 递归向上合并直到无法合并

3. **数据结构**：
   - `pool: Vec<Option<PCB>>`：实际存储PCB对象
   - `free_list: Vec<Vec<usize>>`：多级空闲列表，free_list[k]存储大小为2^k的空闲块

**特点**：
- 真正实现了伙伴系统的分裂和合并
- 支持PCB的实际存储和回收
- 优化内存利用率

### 扩展二 ✓✓✓：进程调度程序

**调度策略**：
1. **优先级调度**：从就绪队列选择优先级最高的进程
2. **时间片轮转**：每个进程分配固定时间片（默认5）
3. **抢占式调度**：时间片用完后自动切换进程

**调度器功能**：
- 记录总执行次数
- 记录进程切换次数
- 维护系统时间
- 提供统计信息显示

### 扩展三 ✓✓✓：PCB回收与合并

**回收算法**：
1. 清除PCB池中的数据
2. 调用伙伴系统的deallocate方法
3. 自动触发伙伴块合并

**合并算法**（伙伴系统核心）：
1. 计算伙伴块索引：`buddy_index = index ^ (1 << order)`
2. 检查伙伴块是否在同一阶的空闲列表中
3. 如果可以合并，移除伙伴块，递归向上合并
4. 如果不能合并，将当前块加入空闲列表

### 快照功能 ✓

- **初始化快照**：系统刚启动，PCB池满，运行队列空
- **运行前快照**：进程执行前的状态
- **运行后快照**：进程执行后的状态
- 显示详细的进程信息和队列状态

## 编译与运行

### 环境要求
- Rust 1.70+ (推荐使用 rustup 安装)

### 编译
```bash
cd os_exp2
cargo build --release
```

### 运行
```bash
cargo run
# 或
cargo run --release
```

## 使用说明

### 主菜单选项

1. **创建进程**：输入优先级创建新进程
2. **撤销进程**：输入PID撤销指定进程
3. **时间片到**：当前运行进程时间片用完
4. **挂起进程**：将指定进程挂起
5. **激活进程**：激活挂起的进程
6. **执行一次调度周期**：执行一次CPU调度
7. **显示系统状态**：显示所有队列的详细状态
8. **生成快照**：生成系统状态快照
9. **批量创建测试进程**：快速创建5个测试进程
0. **退出**：退出程序

### 示例操作流程

1. 启动程序后，系统显示初始化快照
2. 选择 `9` 批量创建测试进程
3. 选择 `6` 执行调度周期，观察进程运行
4. 选择 `4` 挂起某个进程
5. 选择 `5` 激活挂起的进程
6. 选择 `7` 查看系统状态
7. 选择 `8` 生成快照查看状态变化

## 系统架构

### 模块结构

```
os_exp2/
├── src/
│   ├── main.rs          # 主程序，ProcessManager
│   ├── pcb.rs           # PCB数据结构
│   ├── buddy_system.rs  # 伙伴系统实现
│   ├── queue.rs         # 进程队列实现
│   ├── scheduler.rs     # 调度器实现
│   ├── snapshot.rs      # 快照功能
│   └── menu.rs          # 菜单界面
└── Cargo.toml
```

### 核心数据结构

- **PCB**：进程控制块，包含PID、优先级、状态、时间片等
- **ProcessQueue**：进程队列，使用链表实现
- **BuddySystem**：伙伴系统，管理PCB池
- **Scheduler**：调度器，控制CPU调度
- **ProcessManager**：进程管理器，协调所有模块

## 技术特点与创新点

### 1. 真正的伙伴系统实现 ⭐⭐⭐
- **完整的分配算法**：从空闲列表查找、分裂大块
- **完整的回收算法**：计算伙伴、递归合并
- **正确的数据结构**：多级空闲列表、实际存储PCB
- **时间复杂度**：分配和回收都是O(log n)

### 2. 优先级调度 ⭐⭐⭐
- 就绪队列按优先级自动排序
- 每次调度选择优先级最高的进程
- 时间片到后按优先级重新插入

### 3. 高效的总链管理 ⭐⭐
- 使用HashMap而非链表
- O(1)查找和更新
- 状态变化不影响总链结构

### 4. 完整的状态管理 ⭐⭐
- 所有状态转换都同步更新总链和队列
- 保证数据一致性
- 详细的日志输出

### 5. 代码质量 ⭐⭐⭐
- 模块化设计，职责清晰
- 详细的注释说明算法原理
- 使用Rust类型系统保证安全性
- 无unsafe代码

## 算法详解

### 伙伴系统算法

**数据结构设计：**
- 多级空闲列表：`free_list[k]` 存储大小为 2^k 的空闲块
- PCB池：实际存储PCB对象的数组

**分配算法：**
1. 查找最小的可用块
2. 如果块太大，递归分裂成两个伙伴块
3. 返回分配的块索引

**回收算法：**
1. 释放指定索引的块
2. 计算伙伴块索引（XOR运算：`buddy_index = index ^ (1 << order)`）
3. 如果伙伴块空闲，合并成更大的块
4. 递归向上合并直到无法合并

### 优先级调度算法

**调度策略：**
- 就绪队列按优先级排序（优先级高的在前）
- 每次调度选择优先级最高的进程
- 时间片轮转：每个进程分配固定时间片（默认5）

**进程切换：**
- 时间片用完自动触发状态转换（Running → Ready）
- 按优先级重新插入就绪队列

### PCB总链管理

**设计选择：**
- 使用HashMap而非链表，实现O(1)查找和更新
- 总链维护所有进程，状态变化不影响总链结构
- 各队列只存储PID，通过总链获取完整PCB信息

## 使用建议

### 测试流程

1. **基本功能测试**
   ```
   启动程序 -> 选择9批量创建 -> 选择7查看状态 -> 选择8生成快照
   ```

2. **调度测试**
   ```
   创建不同优先级的进程 -> 多次选择6执行调度 -> 观察优先级调度效果
   ```

3. **挂起/激活测试**
   ```
   创建进程 -> 选择4挂起 -> 查看状态 -> 选择5激活 -> 查看状态
   ```

4. **伙伴系统测试**
   ```
   创建多个进程 -> 撤销部分进程 -> 观察PCB池空闲数变化
   ```

5. **统计信息**
   ```
   执行多次调度后 -> 选择s查看调度器统计
   ```

## 注意事项

- PCB池最大容量为128个进程（实际为2^7=128）
- 默认时间片为5个调度周期
- 进程优先级：数值越大优先级越高
- 系统自动维护所有队列的一致性
- 伙伴系统会自动合并相邻的空闲块

## 项目特点

本实现的优势：

1. ✅ **伙伴系统实现** - 完整的分配、分裂、回收、合并算法，不是简单的数组分配
2. ✅ **真正的优先级调度** - 基于优先级队列的调度算法，不是简单的FIFO
3. ✅ **高效的数据结构** - 使用HashMap管理总链，O(1)查找和更新
4. ✅ **高质量代码** - 模块化设计，详细注释，类型安全
5. ✅ **功能完整** - 实现所有基本要求和扩展要求
6. ✅ **经过验证** - 通过完整的功能测试

## 贡献

欢迎提交 Issue 和 Pull Request！

## 许可证

本项目采用 MIT 许可证 - 详见 [LICENSE](LICENSE) 文件。
